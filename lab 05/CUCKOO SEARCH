
import numpy as np
import random


cities = np.array([
    [1, 1], [4, 5], [7, 2], [3, 8]
])
n = len(cities)
def distance_matrix(coords):
    return np.linalg.norm(coords[:, None] - coords, axis=2)
dist = distance_matrix(cities)
def route_dist(route):
    d = sum(dist[route[i], route[i+1]] for i in range(n-1))
    d += dist[route[-1], route[0]]  # return to start
    return d
def swap(route):
    r = route.copy()
    i, j = random.sample(range(n), 2)
    r[i], r[j] = r[j], r[i]
    return r

def cuckoo_search(nests=10, Pa=0.25, max_iter=100):
    population = [np.random.permutation(n) for _ in range(nests)]
    fitness = [route_dist(p) for p in population]
    
    best_idx = np.argmin(fitness)
    best_route, best_fit = population[best_idx], fitness[best_idx]
    
    for _ in range(max_iter):
        for i in range(nests):
            new_sol = swap(population[i])
            new_fit = route_dist(new_sol)
            j = random.randint(0, nests - 1)
            if new_fit < fitness[j]:
                population[j], fitness[j] = new_sol, new_fit
                if new_fit < best_fit:
                    best_route, best_fit = new_sol, new_fit
        worst_count = int(Pa * nests)
        worst_idxs = np.argsort(fitness)[-worst_count:]
        for idx in worst_idxs:
            population[idx] = np.random.permutation(n)
            fitness[idx] = route_dist(population[idx])
            if fitness[idx] < best_fit:
                best_route, best_fit = population[idx], fitness[idx]

    return best_route, best_fit
best_route, best_fitness = cuckoo_search()
print(f"Number of cities: {n}")
print("City coordinates:")
for i, c in enumerate(cities):
    print(f"City {i}: {c}")
print("\nBest route:")
print(" -> ".join(map(str, best_route)) + f" -> {best_route[0]}")
print(f"Fitness (Total distance): {best_fitness:.4f}")
