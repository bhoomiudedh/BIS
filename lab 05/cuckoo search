import numpy as np
import random

cities = np.array([[1,1],[4,5],[7,2],[3,8]])
n = len(cities)
dist = np.linalg.norm(cities[:, None] - cities, axis=2)

def route_dist(route):
    return sum(dist[route[i], route[i+1]] for i in range(n-1)) + dist[route[-1], route[0]]

def swap(route):
    r = route.copy()
    i,j = random.sample(range(n), 2)
    r[i], r[j] = r[j], r[i]
    return r

def cuckoo_search(nests=10, Pa=0.25, max_iter=100):
    population = [np.random.permutation(n) for _ in range(nests)]
    fitness = [route_dist(p) for p in population]

    best_idx = np.argmin(fitness)
    best_route, best_fit = population[best_idx], fitness[best_idx]

    for t in range(1, max_iter+1):
        for i in range(nests):
            new_sol = swap(population[i])
            new_fit = route_dist(new_sol)
            j = random.randint(0, nests-1)
            if new_fit < fitness[j]:
                population[j], fitness[j] = new_sol, new_fit
                if new_fit < best_fit:
                    best_route, best_fit = new_sol, new_fit

        worst_count = int(Pa * nests)
        worst_idxs = np.argsort(fitness)[-worst_count:]
        for idx in worst_idxs:
            population[idx] = np.random.permutation(n)
            fitness[idx] = route_dist(population[idx])
            if fitness[idx] < best_fit:
                best_route, best_fit = population[idx], fitness[idx]

        if t % 10 == 0 or t == 1:
            print(f"Iteration {t}: Best fitness = {best_fit:.4f}")

    return best_route, best_fit

best_route, best_fitness = cuckoo_search()
print("\nBest route:")
print(" -> ".join(map(str, best_route)) + f" -> {best_route[0]}")
print(f"Fitness (Total distance): {best_fitness:.4f}")

