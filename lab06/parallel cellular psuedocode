ALGORITHM CellularAutomataOptimization

INPUT:
    objective_function: function to optimize
    bounds: list of (min, max) for each dimension
    grid_size: size of cellular grid (e.g., 10)
    max_iterations: maximum generations

OUTPUT:
    best_solution: optimal position found
    best_fitness: best fitness value

BEGIN:
    // Step 1: Initialize Parameters
    dim = LENGTH(bounds)
    best_solution = NULL
    best_fitness = INFINITY
    
    // Step 2: Initialize Population
    cells = CREATE_GRID(grid_size, grid_size, dim)
    FOR i = 0 TO grid_size-1:
        FOR j = 0 TO grid_size-1:
            FOR d = 0 TO dim-1:
                min_val, max_val = bounds[d]
                cells[i][j][d] = RANDOM(min_val, max_val)
            END FOR
        END FOR
    END FOR
    
    // Step 3-6: Main Loop
    FOR iteration = 1 TO max_iterations:
        
        // Step 4: Evaluate Fitness
        fitness = CREATE_GRID(grid_size, grid_size)
        FOR i = 0 TO grid_size-1:
            FOR j = 0 TO grid_size-1:
                fitness[i][j] = objective_function(cells[i][j])
                
                // Update global best
                IF fitness[i][j] < best_fitness:
                    best_fitness = fitness[i][j]
                    best_solution = COPY(cells[i][j])
                END IF
            END FOR
        END FOR
        
        // Step 5: Update Cell States
        new_cells = COPY(cells)
        FOR i = 0 TO grid_size-1:
            FOR j = 0 TO grid_size-1:
                
                // Get neighbors (up, down, left, right)
                neighbors = []
                FOR (di, dj) IN [(-1,0), (1,0), (0,-1), (0,1)]:
                    ni = (i + di) MOD grid_size
                    nj = (j + dj) MOD grid_size
                    neighbors.ADD(cells[ni][nj])
                END FOR
                
                // Find best neighbor
                best_neighbor = NULL
                best_neighbor_fitness = INFINITY
                FOR EACH neighbor IN neighbors:
                    neighbor_fitness = objective_function(neighbor)
                    IF neighbor_fitness < best_neighbor_fitness:
                        best_neighbor_fitness = neighbor_fitness
                        best_neighbor = neighbor
                END FOR
                
                // Update rule
                IF best_neighbor_fitness < fitness[i][j]:
                    // Move toward better neighbor
                    new_cells[i][j] = 0.5 * cells[i][j] + 0.5 * best_neighbor
                ELSE:
                    // Random local search
                    new_cells[i][j] = cells[i][j] + SMALL_RANDOM_PERTURBATION()
                END IF
                
                // Apply bounds
                FOR d = 0 TO dim-1:
                    min_val, max_val = bounds[d]
                    new_cells[i][j][d] = CLAMP(new_cells[i][j][d], min_val, max_val)
                END FOR
                
            END FOR
        END FOR
        
        cells = new_cells
        
    END FOR
    
    // Step 7: Output Best Solution
    RETURN best_solution, best_fitness

END ALGORITHM
